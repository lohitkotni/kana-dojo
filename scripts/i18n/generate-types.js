#!/usr/bin/env node
/**
 * Generate TypeScript types from translation files
 *
 * This script generates TypeScript type definitions for translation keys
 * to enable autocomplete and type checking when using the t() function.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const LOCALES_DIR = path.resolve(__dirname, '../../core/i18n/locales');
const OUTPUT_FILE = path.resolve(__dirname, '../../core/i18n/types.d.ts');
const REFERENCE_LANG = 'en';

const NAMESPACES = [
  'common',
  'navigation',
  'kana',
  'kanji',
  'vocabulary',
  'achievements',
  'statistics',
  'settings',
  'errors',
  'menuInfo',
  'blog'
];

/**
 * Convert nested object to TypeScript type definition
 */
function objectToType(obj, indent = 0) {
  const spaces = '  '.repeat(indent);
  const lines = [];

  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      lines.push(`${spaces}${key}: {`);
      lines.push(objectToType(value, indent + 1));
      lines.push(`${spaces}};`);
    } else {
      lines.push(`${spaces}${key}: string;`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate TypeScript interface from JSON file
 */
function generateInterface(namespace) {
  const filePath = path.join(LOCALES_DIR, REFERENCE_LANG, `${namespace}.json`);

  if (!fs.existsSync(filePath)) {
    console.error(`‚ùå File not found: ${filePath}`);
    return null;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const data = JSON.parse(content);

    const interfaceName =
      namespace.charAt(0).toUpperCase() + namespace.slice(1) + 'Translations';

    const typeDefinition = `export interface ${interfaceName} {
${objectToType(data, 1)}
}`;

    return typeDefinition;
  } catch (error) {
    console.error(`‚ùå Error processing ${namespace}:`, error.message);
    return null;
  }
}

/**
 * Main function
 */
function main() {
  console.log('üî® Generating TypeScript types for translations...\n');

  const interfaces = [];
  const namespaceTypes = [];

  for (const namespace of NAMESPACES) {
    console.log(`Processing ${namespace}...`);
    const interfaceDef = generateInterface(namespace);

    if (interfaceDef) {
      interfaces.push(interfaceDef);
      const typeName =
        namespace.charAt(0).toUpperCase() + namespace.slice(1) + 'Translations';
      namespaceTypes.push(`  ${namespace}: ${typeName};`);
    }
  }

  // Generate the complete file
  const fileContent = `/**
 * Auto-generated translation types
 * DO NOT EDIT MANUALLY - Generated by scripts/i18n/generate-types.ts
 * 
 * Run: npm run i18n:generate-types
 */

${interfaces.join('\n\n')}

/**
 * Complete translation structure with all namespaces
 */
export interface Translations {
${namespaceTypes.join('\n')}
}

/**
 * Type for translation keys with dot notation
 * Usage: const key: TranslationKey = 'common.buttons.submit';
 */
export type TranslationKey = 
${NAMESPACES.map(ns => `  | \`${ns}.\${keyof ${ns.charAt(0).toUpperCase() + ns.slice(1)}Translations}\``).join('\n')};

/**
 * Available namespaces
 */
export type Namespace = ${NAMESPACES.map(ns => `'${ns}'`).join(' | ')};

/**
 * Available languages
 */
export type Locale = 'en' | 'es' | 'ja' | 'pt' | 'fr' | 'de' | 'it' | 'zh' | 'ko' | 'ru' | 'ar';
`;

  // Write to file
  fs.writeFileSync(OUTPUT_FILE, fileContent, 'utf8');

  console.log('\n‚úÖ TypeScript types generated successfully!');
  console.log(`üìÅ Output: ${OUTPUT_FILE}`);
}

main();
